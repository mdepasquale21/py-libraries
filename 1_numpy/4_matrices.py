# MATRICES
print('MATRICES')

print('In numpy there is a np.matrix object, but its usage is not recommended.')
print('np.matrix is fixed to 2 dimensions, whereas a np.array can have many dimensions and is thus more general.')
print('Usually np.array is preferred to np.matrix!')
print('One important exception is a sparse matrix object in scipy, which is very useful in many applications (e.g Recommender Systems).')
print('\n')

print('If we use a list of lists to define a matrix')
L = [[1,2],[3,4]]
print(L)
print('Access first row as list[0]')
print(L[0])
print('Access first row, second column as list[0][1]')
print(L[0][1])

import numpy as np

print('\n')
print('If we use numpy')
A = np.array([[1,2],[3,4]])
print(A)
print('Access first row as array[0,:]')
print(A[0,:])
print('or simply array[0]')
print(A[0])
print('Access first row second column as array[0,1]')
print(A[0,1])
print('array[0][1] can also be done')
print(A[0][1])
print('but array[:,:] notation seems more convenient!')

print('We can also select a column from the array!')
print('In lists you cannot do it!')
print('By using array[:,0] (first column)')
print(A[:,0])

print('We can also transpose the array with array.T')
print('In lists you cannot do it!')
print(A.T)

print('We can also apply a function element-wise to the array')
print('e.g. the exponential np.exp(array)')
print(np.exp(A))
#print(np.exp(L))
print('also in lists you can do it actually...')
print('np.exp(list) treats the list as a numpy array!')
print('and returns a np.array!!')
print('Many functions do this!')
print('E.g. you can just pass lists to functions in sklearn or matplotlib, you do not need to convert them to np arrays before!')

print('\n')
print('Matrix Multiplication')
print('Let us create a 2x3 matrix with numpy, call it B')
B = np.array([[1,2,3],[4,5,6]])
print(B)
print('Recall the matrix before, call it A')
print(A)
print('And let us do the multiplication A.dot(B)')
print(A.dot(B))
print('This is the matrix multiplication, row by column (inner matrix product)')
print('A*B would make the element-wise product and in this case give a broadcasting error because of the different shapes!')
print('Of course matrix multiplication is only possible when')
print('The number of columns of the first matrix is equal to the number of rows of the second matrix')
print('e.g. in the example A is 2x2 and B is 2x3 -> result is 2x3, in general mxn and nxp -> result is mxp')

print('\n')
print('Matrix determinant')
print('np.linalg.det(A)')
print(np.linalg.det(A))
print('Inverse Matrix')
print('np.linalg.inv(A)')
print(np.linalg.inv(A))
print('A.dot(invA)')
print(A.dot(np.linalg.inv(A)))
print('Matrix trace')
print('np.trace(A)')
print(np.trace(A))
print('Matrix diagonal')
print('np.diag(A)')
print(np.diag(A))
print('np.diag can also be used to initialize a diagonal matrix by passing a 1-D array or list to it')
print('e.g. np.diag([7,8])')
print(np.diag([7,8]))
print('This method is overloaded, if you pass a matrix you obtain a vector with the diagonal elements of that matrix')
print('If you pass a vector, you get a matrix whose diagonal elements are the ones from the vector and all the others are 0')
print('\n')
print('Eigenvalues & Eigenvectors')
print('np.linalg.eig(A)')
print('-> returns first an array containing the eigenvalues, then a matrix containing the eigenvectors')
print(np.linalg.eig(A))
print('Let us unpack them')
lam, v = np.linalg.eig(A)
print('Eigenvalues:', lam)
print('Eigenvectors:', v)
print('Let us check for the first eigenvalue and eigenvector that A*v = lambda*v!')
print('is it true that A.dot(v[:,0]) == lam[0]*v[:,0]??')
print('(By convention eigenvectors are stored as column vectors)')
print(A.dot(v[:,0]) == lam[0]*v[:,0]) # this returns [True, False]
print('Check results singularly')
print(A.dot(v[:,0]))
print(lam[0]*v[:,0])
print('They are in fact equal!')
print('== returns element-wise comparison in case of vectors!')
print('but we would like to have [True, True] as a result and this is not the case!')
print('This is an error due to numerical precision')
print('The correct way in numpy to compare if arrays are equal is to use the np.allclose() function')
print('is it true that np.allclose(A.dot(v[:,0]),lam[0]*v[:,0])??')
print(np.allclose(A.dot(v[:,0]),lam[0]*v[:,0]))
print('We can check all the eigenvectors at the same time with matrix notation')
print('np.allclose(v@np.diag(lam), A@v)')
print(np.allclose(v@np.diag(lam), A@v))
print('If the matrix is symmetric (or hermitian when dealing with complex numbers)')
print('then np.linalg.eigh() can be used and is more convenient for that scenario!')
